# A namespace groups declarations into a logical unit
namespace MyNs {
    # Binding initializers in a namespace cannot directly access items declared after them.
    # let my_val = top_level # error: cannot access top_level as it is uninitialized.
    # You can still reference items declared after in function bodies. Calling such a function before the referenced
    # item is initialized will crash the program
    let my_fun = { -> top_level }
}

let top_level = "top level"

# a namespace can be "redeclared" to continue declaring items. The subsequent declarations will be merged into the
# same namespace. For example, this is the same MyNs namespace as above, not a conflicting declaration.
namespace MyNs {
    let inner = top_level
}

# A namespace declaration can declare several nested namespaces use . syntax. This also works with redeclaration
namespace MyNs.InnerNs {

}
# Equivalent to
namespace MyNs {
    namespace InnerNs {

    }
}

# Items within a namespace may elide the namespace prefix with referencing other items within the same or a parent namespace
namespace MyNs {
    let x = ()
    let y = x # equivalent to `let y = MyNs.x`
    namespace InnerNs {
        let z = x # equivalent to `let z = MyNs.x`
    }
    let w = InnerNs.z # equivalent to `let w = MyNs.InnerNs.z`
}

# Items in a namespace must be declared public to be visible from outside the namespace. The declaration AND all of the
# intermediate namespaces must be declared public. Only one of a
# However, as seen above, expressions in a namespace may access anything at *either* a higher lexical level or a higher
# namespace level.
public namespace MyNs.InnerNs {
    public let n = inner
}
# Namespace members are accessed with . syntax
let myns_n = MyNs.InnerNs.n

# visibility
namespace Wrap {
    namespace Blah {
        public let x = 5 # visibility: Wrap
        let z = 5 # visibility: Wrap.Blah
    }
    public namespace Blah {
        public let y = 5 # visibility: <root>
        let zz = z # visibility: Wrap.Blah
    }
    let _ = Blah.x # fine
}
# let x = Wrap.Blah.x  # error cannot access x in Wrap.Blah
let y = Wrap.Blah.y # fine

# Public applies to all nested Ns when declared with . syntax
public namespace MyNs.InnerNs {}
# is equivalent to:
public namespace MyNs {
    public namespace InnerNs {
    }
}

namespace A {
    type A
}
namespace A {
    let a1: A = new { }
    # Can also do
    let a2: A.A = new { }
}

# lexical resolution trumps ns resolution. Note: namespaces do not create new lexical scopes, even top level.
# Declarations in a namespace (even top-level) cannot be resolved lexically
let y = 1
namespace Foo.Bar {
    let x = 2
}
namespace Foo {
    let x = 3
    let y = 4
    namespace Bar {
        let z = 5
        let f = { -> (println x) } # will print 2
        let g = { -> (println y) } # will print 4
        let h = { ->
            let z = 6
            (println z) # will print 6
        }
    }
}
