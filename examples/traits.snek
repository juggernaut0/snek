# There is no special language support for polymorphism, traits or typeclasses
# However, you can make a record type with function fields and pass that around as a "polymorphic" bundle.

type Iterator<T> { current: { -> Option<T> }, advance: { -> Iterator<T> } }

let for_each = { <T> f: { T -> () } { current, advance }: Iterator<T> ->
    (match (current)
        { _: None -> () }
        { x -> (f x) (. f (advance)) }
    )
}

let list = [1 2 3]
let as_iterator = { l: List<Number> ->
    new Iterator { current: { -> (List.head l) }, advance: { -> (as_iterator (List.tail l)) } }
}
(for_each println (as_iterator list))

type Default<T> { default: { -> T } }
let fill_list: { <T> Default<T> Number -> List<T> } = { { default } n ->
    (match n
        { 0 -> [] }
        { _ -> (List.cons (default) (make_list default (n - 1)) }
    )
}

let number_default = new Default<Number> { default: { -> 0 } }
let zeros = (fill_list number_default 5) # [0 0 0 0 0]

type ToString { to_string: { -> String } }
namespace Number {
    let to_string: { Number -> String } = (TODO)
    let impl_to_string = { it: Number -> new ToString { to_string: { -> (to_string it) } } }
}
namespace String {
    let impl_to_string = { it: String -> new ToString { to_string: { -> it } } }
}

let stringables: List<ToString> = [(Number.impl_to_string 55) (String.impl_to_string "shfifty five")]
(for_each { { to_string } -> (println (to_string)) } stringables)
