# There is no special language support for polymorphism, traits or typeclasses
# However, you can make a record type with function fields and pass that around as a "polymorhic" bundle.

type Iterator<T> { current: { -> Option<T> }, advance: { -> Iterator<T> } }

let for_each = { f: { * -> () } { current, advance }: Iterator<*> ->
    (match (current)
        { _: None -> () }
        { x -> (f x) (. f (advance)) }
    )
}

let list = [1 2 3]
let as_iterator = { l: List<Number> ->
    new Iterator { current: { -> (List.head l) }, advance: { -> (as_iterator (List.tail l)) } }
}
(for_each println (as_iterator list))
