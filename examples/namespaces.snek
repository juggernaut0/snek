# A namespace groups declarations into a logical unit
namespace MyNs {
    let my_fun = { -> 5 }
}

# Binding initializers in a namespace cannot access items declared after them. However, a namespace can be "redeclared".
# The subsequent declarations will be merged into the first.
let top_level = "top level"

# Same namespace as above, not a conflicting declaration
namespace MyNs {
    let inner = top_level
}

# A namespace declaration can declare several nested namespaces use . syntax. This also works with redeclaration
namespace MyNs.InnerNs {

}
# Equivalent to
namespace MyNs {
    namespace InnerNs {

    }
}

# Items in a namespace must be declared public to be visible from outside the namespace
# However, as seen above, expressions in a namespace may access anything at *either* a higher lexical level or a higher
# namespace level.
public namespace MyNs.InnerNs {
    public let n = inner
}
# Namespace members are accessed with . syntax
let myns_n = MyNs.InnerNs.n

namespace A {
    type A
}
namespace A {
    let a1: A = new { }
    # Can also do
    let a2: A.A = new { }
}

# namespace resolution trumps lexical, EXCEPT at root level
let y = 4
namespace Foo.Bar {
    let x = 2
}
namespace Foo {
    let x = 1
    let y = 3
    namespace Bar {
        let f = { -> (println x) } # will print 2
        let g = { -> (println y) } # will print 3
    }
}
