type Foo { a: Number, b: String } # Foo is a record, can be instantiated
type Bar = Foo | String # Bar is a union, cannot be directly instantiated but will match any of its cases
type MyFoo = Foo # A union with only one case acts as an alias.

# generic type
type Some<T> { t: T }
# empty type
# equivalent: type None {}
type None
# types may have visibility modifiers. Not all of a union's cases must be public for the union itself to be public.
public type Option<T> = Some<T> | None
# Generic types may be specialized in unions
type OptionalNumber = Some<Number> | None

# shorthand - declares Some and None record types inline
# note, braces after None are required here to declare new type rather than reference an existing type
# note, record types defined inline can be made public independent of the parent union
# note, record types defined inline inherit ALL of the type parameters of the parent union. Here, Some2 is parameterized
# by T just as above. However, this None2 is also parameterized which may not be desired.
public type Option2<T> = public Some2 { t: T } | None2 { }

# You may not define type parameters on records defined inline in unions
# type Foo = Bar<U> { u: U } -- Error
# Instead, define the type parameter on the union and use it in the record (as seen above with Option) or define the
# record separately

# For empty record types, you may want to provide a singleton
public let None = new None { }

# Compile Error: A union type may not be directly recursive. Wrap with a record type
# type Bad = Foo | Bad
type List = Empty { } | Cons { h: Number, t: List }

# Instantiating a type directly:
let foo = new Foo { a: 1337, b: "Hello" }
let box = new Some<Number> { t: 0 }
# Can omit type if it can be inferred some other way
let foo: Foo = new { a: 1337, b: "Hello" }
# You can only construct a type if it and all of its fields are visible in the current scope

# You'll most likely want to keep your types private and provide public constructors and aliases
public type NonZero = NonZeroImpl { value: Number }
public let NonZero: { Number -> Option<NonZero> } = { x ->
    (match x
        { 0 -> None }
        { _ -> new NonZeroImpl { value: x } }
    )
}
#Usage
let nz: NonZero = (Option.unwrap (NonZero 5))

# Accessing a record type's fields can be done by destructuring. Types can be inferred
let { a: Number, b } = foo
# Use let again to rename or further match
let { let mynum = a, b } = foo
# Partial destructuring works
let { a } = foo
# Compile error: Cannot destructure an empty record
# let { } = None

# Accessing the cases of a union: You must match and provide an arm for each possible case
# If a union's cases are not all visible in a given scope, matches against the union must include a wildcard (_) match
# in order to be exhaustive.
let x: Option<Number> = (some_func)
let _ = (match x
    { _: None -> (println "Nothing!") }
    { { let n = t }: Some<Number> -> (println n) }
)

# A type can be specified as '*', meaning Any
let any_list: List<*> = [1 'b' false]

# A type can be specified as '_', meaning inferred.
# num_list has type List<Number>
let num_list: List<_> = [1 2 3]
# any_list has type List<*>
let any_list: List<_> = [1 'b' false]

# The type '!' represents an expression that never returns, e.g. an infinite loop or program termination
let never: ! = (exit 0)
let looper: { -> ! } = { -> (.) }
