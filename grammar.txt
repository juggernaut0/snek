program = import* decl* call_expr?
import = 'import' qualified_name* 'from' STRING
qualified_name = IDENT ('.' IDENT)*
decl = 'public'? (namespace | type | binding)
namespace = 'namespace' qualified_name decl_block
decl_block = '{' decl* '}'
type = 'type' IDENT (IDENT* | '=' type_cases) decl_block?
type_cases = IDENT+ ('|' IDENT+)*
binding = 'let' pattern '=' expr

pattern = const_literal |
	wildcard_pattern |
	name_pattern |
	list_pattern |
	type_pattern |
wildcard_pattern = '_'
name_pattern = IDENT
list_pattern = '[' pattern* ']'
type_pattern = '(' qualified_name pattern* ')'

block = (binding | call_expr | binary_expr)* expr
expr = call_expr | binary_expr | qualified_name | lambda | list_expr | const_literal
call_expr = '(' ('.' | expr) expr* ')'
binary_expr = '(' unary_expr (binary_op unary_expr)* ')'
binary_op = '+' | '-' | '*' | '/' | '<=' | '<' | '>=' | '>' | '==' | '!=' | '&&' | '||'
unary_expr = unary_op? expr
unary_op = '+' | '-' | '!'
lambda = '{' pattern* '->' block '}'
list_expr = '[' expr* ']'
const_literal = NUMBER | STRING | 'true' | 'false' | '(' ')'

IDENT = [^\(\)\[\]\.]+
NUMBER = \d+(\.\d*)?
STRING = \'[^\n\r]*?\'|\"[^\n\r]*?\"

COMMENT = #.*?(?=\n|$)

KEYWORDS:
	import
	from
	public
	namespace
	type
	let
	method
	impl
	true
	false

SYMBOLS:
	.
	{
	}
	(
	)
	[
	]
	->
	+
	-
	*
	/
	<=
	<
	>=
	>
	==
	=
	!=
	!
	&&
	|
	||
