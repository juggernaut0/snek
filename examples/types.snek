type Foo { a: Number, b: String } # Foo is a record, can be instantiated
type Bar = Foo | String # Bar is a union, cannot be directly instantiated but will match any of its cases
type MyFoo = Foo # A union with only one case is an alias.

# generics
type Some<T> { t: T }
# empty
type None
# equivalent: type None {}
type Option<T> = Some<T> | None

# shorthand - declares Some and None record types inline
# note, braces after None are required here to declare new type rather than reference an existing type
# note, record types defined inline can be made public independent of the parent union
# note, record types defined inline inherit ALL of the type parameters of the parent union. Here, Some is parameterized
# by T just as above
public type Option<T> = public Some { t: T } | None { }

# You may not define type parameters on records defined inline in unions
# type Foo = Bar<U> { u: U } -- Error
# Instead, define the type parameter on the union and use it in the record (as seen above with Option)

# For empty record types, you may want to provide a singleton
public let None = new None { }

# Compile Error: A union type may not be directly recursive. Wrap with a record type
# type Bad = Foo | Bad
type List = Empty { } | Cons { h: Number, t: List }

# Instantiating a type directly:
let foo = new Foo { a: 1337, b: "Hello" }
let box = new Some<Number> { t: 0 }
# Can omit type if it can be inferred some other way
let foo: Foo = new { a: 1337, b: "Hello" }
# You can only construct a type if all of its fields are accessible

# You'll most likely want to keep your types private and provide public constructors and aliases
public type NonZero = NonZeroImpl { value: Number }
public let NonZero: { Number -> Option<NonZero> } = { x ->
    (match x
        { 0 -> None }
        { _ -> new NonZeroImpl { value: x } }
    )
}
#Usage
let nz: NonZero = (Option.unwrap (NonZero 5))

# Accessing a record type's fields can be done by destructuring. Types can be inferred
let { a: Number, b } = foo
# Use let again to rename or further match
let { let mynum = a, b } = foo
# Partial destructuring works
let { a } = foo
# Compile error: Cannot destructure an empty record
# let { } = None

# Accessing the members of a union: You must match and provide an arm for each possible case
let x: Option<Number> = (some_func)
let _ = (match x
    { _: None -> (println "Nothing!") }
    { n: Number -> (println n) }
)

# A type can be specified as '*', meaning Any
let any_list: List<*> = [1 'b' false]

# A type can be specified as '_', meaning inferred.
# num_list has type List<Number>
let num_list: List<_> = [1 2 3]
# any_list has type List<*>
let any_list: List<_> = [1 'b' false]

# The type '!' represents an expression that never returns, e.g. an infinite loop or program termination
let never: ! = (exit 0)
let looper: { -> ! } = { -> (.) }
