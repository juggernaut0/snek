# A namespace groups declarations into a logical unit
namespace MyNs {
    let my_fun = { -> 5 }
}

# Binding initializers in a namespace cannot access items declared after them. However, a namespace can be "redeclared".
# The subsequent declarations will be merged into the first.
let top_level = "top level"

# Same namespace as above, not a conflicting declaration
namespace MyNs {
    let inner = top_level
}

# A namespace declaration can declare several nested namespaces use . syntax. This also works with redeclaration
namespace MyNs.InnerNs {

}
# Equivalent to
namespace MyNs {
    namespace InnerNs {

    }
}

# Items in a namespace must be declared public to be visible from outside the namespace. The declaration AND all of the
# intermediate namespaces must be declared public. Only one of a
# However, as seen above, expressions in a namespace may access anything at *either* a higher lexical level or a higher
# namespace level.
public namespace MyNs.InnerNs {
    public let n = inner
}
# Namespace members are accessed with . syntax
let myns_n = MyNs.InnerNs.n

# visiblity
namespace Wrap {
    namespace Blah {
        public let x = 5 # visibility: Wrap
        let z = 5 # visibility: Wrap.Blah
    }
    public namespace Blah {
        public let y = 5 # visibility: <root>
        let zz = z # visibility: Wrap.Blah
    }
    let _ = Blah.x # fine
}
# let x = Wrap.Blah.x  # error cannot access x in Wrap.Blah
let y = Wrap.Blah.y # fine

# Public applies to all nested Ns when declared with . syntax
public namespace MyNs.InnerNs {}
# is equivalent to:
public namespace MyNs {
    public namespace InnerNs {
    }
}

namespace A {
    type A
}
namespace A {
    let a1: A = new { }
    # Can also do
    let a2: A.A = new { }
}

# lexical resolution trumps ns resolution. Note: namespaces do not create new lexical scopes, even top level.
# Declarations in a namespace (even top-level) cannot be resolved lexically
let y = 1
namespace Foo.Bar {
    let x = 2
}
namespace Foo {
    let x = 3
    let y = 4
    namespace Bar {
        let z = 5
        let f = { -> (println x) } # will print 2
        let g = { -> (println y) } # will print 4
        let h = { ->
            let z = 6
            (println z) # will print 6
        }
    }
}
